<!doctype html>
<html style="margin:0; padding:0; border:0; width:100%; height:100%;">

<head>
	<title>WebGL2 spike page</title>
	<meta http-equiv='Content-Type' content='text/html; charset=utf-8'>
	<meta name="viewport" content="width=device-width, initial-scale=1">
</head>

<body style="margin:0; padding:0; border:0; width:100%; height:100%; overflow:hidden; background-color:#333;">

	<style>
		.hidden { display:none; }
		.centre { overflow:hidden; align-self:center; justify-self:center; }
		.loader { background-color:#000000; color:#AAAAAA; padding:1em; }
		.canvas { height:100%; image-rendering: pixelated; }
		p { 
			font-family: 'Courier New', monospace;
			font-size: 16pt;
		}
	</style>
	
    <!-- Display canvas -->

	<canvas id="gameScreen" width="320" height="256" class="centre canvas">
		<p>Web Canvas isn't supported by this browser, so the game cannot be displayed.</p>
	</canvas>

    <!-- Supplementary scripts could possibly be done in F# itself through Fable -->

    <script>
	
	
	
  function m3multiply(a, b) {
    var a00 = a[0 * 3 + 0];
    var a01 = a[0 * 3 + 1];
    var a02 = a[0 * 3 + 2];
    var a10 = a[1 * 3 + 0];
    var a11 = a[1 * 3 + 1];
    var a12 = a[1 * 3 + 2];
    var a20 = a[2 * 3 + 0];
    var a21 = a[2 * 3 + 1];
    var a22 = a[2 * 3 + 2];
    var b00 = b[0 * 3 + 0];
    var b01 = b[0 * 3 + 1];
    var b02 = b[0 * 3 + 2];
    var b10 = b[1 * 3 + 0];
    var b11 = b[1 * 3 + 1];
    var b12 = b[1 * 3 + 2];
    var b20 = b[2 * 3 + 0];
    var b21 = b[2 * 3 + 1];
    var b22 = b[2 * 3 + 2];

    return [
      b00 * a00 + b01 * a10 + b02 * a20,
      b00 * a01 + b01 * a11 + b02 * a21,
      b00 * a02 + b01 * a12 + b02 * a22,
      b10 * a00 + b11 * a10 + b12 * a20,
      b10 * a01 + b11 * a11 + b12 * a21,
      b10 * a02 + b11 * a12 + b12 * a22,
      b20 * a00 + b21 * a10 + b22 * a20,
      b20 * a01 + b21 * a11 + b22 * a21,
      b20 * a02 + b21 * a12 + b22 * a22,
    ];
  }
  
		  function m3projection(width, height) {
			// Note: This matrix flips the Y axis so 0 is at the top.
			return [
			  2 / width, 0, 0,
			  0, -2 / height, 0,
			  -1, 1, 1,
			];
		  }	
	
  function m3project(m, width, height) {
    return m3multiply(m, m3projection(width, height));
  }
  
  function m3translation(tx, ty) {
    return [
      1, 0, 0,
      0, 1, 0,
      tx, ty, 1,
    ];
  }	
  function m3translate(m, tx, ty) {
    return m3multiply(m, m3translation(tx, ty));
  }

  function m3rotation(angleInRadians) {
    var c = Math.cos(angleInRadians);
    var s = Math.sin(angleInRadians);
    return [
      c, -s, 0,
      s, c, 0,
      0, 0, 1,
    ];
  }  
	
  function m3rotate(m, angleInRadians) {
    return m3multiply(m, m3rotation(angleInRadians));
  }	
	
  function m3scaling(sx, sy) {
    return [
      sx, 0, 0,
      0, sy, 0,
      0, 0, 1,
    ];
  }	
	
  function m3scale(m, sx, sy) {
    return m3multiply(m, m3scaling(sx, sy));
  }	
	
	
	
		function compileShader(gl, shaderSource, shaderType) {
		  // Create the shader object
		  var shader = gl.createShader(shaderType);
		 
		  // Set the shader source code.
		  gl.shaderSource(shader, shaderSource);
		 
		  // Compile the shader
		  gl.compileShader(shader);
		 
		  // Check if it compiled
		  var success = gl.getShaderParameter(shader, gl.COMPILE_STATUS);
		  if (!success) {
			// Something went wrong during compilation; get the error
			throw "could not compile shader:" + gl.getShaderInfoLog(shader);
		  }
		 
		  return shader;
		}	
			
		function compileVertexShaderFromScript(gl, shaderScript) {
		  return compileShader(gl, shaderScript, gl.VERTEX_SHADER);
		}

		function compileFragmentShaderFromScript(gl, shaderScript) {
		  return compileShader(gl, shaderScript, gl.FRAGMENT_SHADER);
		}
		
		function createProgram(gl, vertexShaderScript, fragmentShaderScript) {
		  // create a program.
		  var program = gl.createProgram();
		 
		  // attach the shaders.
		  gl.attachShader(program, compileVertexShaderFromScript(gl, vertexShaderScript));
		  gl.attachShader(program, compileFragmentShaderFromScript(gl, fragmentShaderScript));
		 
		  // link the program.
		  gl.linkProgram(program);
		 
		  // Check if it linked.
		  var success = gl.getProgramParameter(program, gl.LINK_STATUS);
		  if (!success) {
			  // something went wrong with the link
			  throw ("program filed to link:" + gl.getProgramInfoLog (program));
		  }
		 
		  return program;
		};	
	
	/* I don't need his resize technique because the retro screen is the target and is always the same size.
	
		function resizeCanvasToDisplaySize(canvas) {
		  // Lookup the size the browser is displaying the canvas in CSS pixels.
		  const displayWidth  = canvas.clientWidth;
		  const displayHeight = canvas.clientHeight;
		 
		  // Check if the canvas is not the same size.
		  const needResize = canvas.width  !== displayWidth ||
							 canvas.height !== displayHeight;
		 
		  if (needResize) {
			// Make the canvas the same size
			canvas.width  = displayWidth;
			canvas.height = displayHeight;
		  }
		 
		  return needResize;
		}	
	*/
	
	
	
	
	
	
	
		// ---------------------------------------------------------------------------------------------------
		//   Rectangle Vertex and Fragment shaders
		// ---------------------------------------------------------------------------------------------------

			/*
			A Vertex Shader's job is to generate clipspace coordinates.
			
			Your shader is called once per vertex. Each time it's called 
			you are required to set the special global variable, 
			gl_Position to some clipspace coordinates.
			 
			Vertex shaders need data. They can get that data in 3 ways.
			- Attributes (data pulled from buffers)
			- Uniforms (values that stay the same for all vertices of a single draw call)
			- Textures (data from pixels/texels)
			
			https://webgl2fundamentals.org/webgl/lessons/webgl-shaders-and-glsl.html
			*/
			
			/*
			A Fragment Shader's job is to provide a color for the current pixel being rasterized.
			
			Your fragment shader is called once per pixel. Each time it's called you are required 
			to set your out variable to some color.
			
			Fragment shaders need data. They can get data in 3 ways
			- Uniforms (values that stay the same for every pixel of a single draw call)
			- Textures (data from pixels/texels)
			- Varyings (data passed from the vertex shader and interpolated)			
			*/

		var rectangleVertexShader = 
		
			`#version 300 es
			in vec2 a_position;
			uniform mat3 u_matrix;

			void main() {
			  // Multiply the position by the matrix.
			  gl_Position = vec4((u_matrix * vec3(a_position, 1)).xy, 0, 1);
			  // gl_Position = vec4(a_position.xy,0,1);
			}
			`;

		var rectangleFragmentShader = 
		
			`#version 300 es
			precision highp float;
			uniform vec4 u_color;
			out vec4 outColor;

			void main() {
			  outColor = u_color;
			}
			`;

		// ---------------------------------------------------------------------------------------------------
		//   Image-portion Vertex and Fragment shaders
		// ---------------------------------------------------------------------------------------------------

		var imagePortionVertexShader = 
		
			`#version 300 es

			in vec2 a_position;
			in vec2 a_texcoord;

			uniform mat3 u_matrix;
			uniform mat3 u_textureMatrix;

			out vec2 v_texcoord;

			void main() {
				gl_Position = vec4((u_matrix * vec3(a_position, 1)).xy, 0, 1);
				v_texcoord = (u_textureMatrix * vec3(a_texcoord, 1)).xy;
			}`;

		var imagePortionFragmentShader = 
		
			`#version 300 es
			
			precision highp float;
			in vec2 v_texcoord;
			uniform sampler2D u_texture;
			out vec4 outColor;
			
			void main() {
				outColor = texture(u_texture, v_texcoord);
			}`;

		// ---------------------------------------------------------------------------------------------------
		//   Image 1:1 Vertex and Fragment shaders
		// ---------------------------------------------------------------------------------------------------

		var imageOneToOneVertexShader = 
		
			`#version 300 es

			in vec2 a_position;
			in vec2 a_texcoord;

			uniform mat3 u_matrix;

			out vec2 v_texcoord;

			void main() {
				gl_Position = vec4((u_matrix * vec3(a_position, 1)).xy, 0, 1);
				v_texcoord = a_texcoord;
			}`;

		var imageOneToOneFragmentShader =   // TODO:  This is actually the same as the fragment shader above.
		
			`#version 300 es
			
			precision highp float;
			in vec2 v_texcoord;
			uniform sampler2D u_texture;
			out vec4 outColor;
			
			void main() {
				outColor = texture(u_texture, v_texcoord);
			}`;






		function main(image1) {

			// Get A WebGL context
			/** @type {HTMLCanvasElement} */
			var canvas = document.getElementById("gameScreen");
			var gl = canvas.getContext("webgl2", { antialias:false });
			if (!gl) {
				return;
			}
			
			// ---------------------------------------------------------------------------------------------------
			//   Setup that's outside of all GL-programs:
			// ---------------------------------------------------------------------------------------------------

			gl.viewport(0, 0, 320, 256);  // TODO: use of 320 256
			gl.clearColor(0, 0, 0, 255);  // TODO: Should we do this?
			gl.clear(gl.COLOR_BUFFER_BIT | gl.DEPTH_BUFFER_BIT);

			var projectToRetroScreenMatrix = m3projection(320, 256); // This is a constant

			// ---------------------------------------------------------------------------------------------------
			//   Setup GLSL program for solid filled rectangle drawing:
			// ---------------------------------------------------------------------------------------------------

			var rectangleProgram          = createProgram(gl, rectangleVertexShader, rectangleFragmentShader);
			var rectanglePositionLocation = gl.getAttribLocation(rectangleProgram, "a_position");
			var rectangleColorLocation    = gl.getUniformLocation(rectangleProgram, "u_color");
			var rectangleMatrixLocation   = gl.getUniformLocation(rectangleProgram, "u_matrix");

			var rectangleVao = gl.createVertexArray();
			gl.bindVertexArray(rectangleVao);

			// Reserve a buffer for the solid filled rectangle vertices.
			var rectangleBuffer = gl.createBuffer();
			gl.bindBuffer(gl.ARRAY_BUFFER, rectangleBuffer);
			gl.bufferData(gl.ARRAY_BUFFER, new Float32Array([ 0,0, 0,0, 0,0, 0,0, 0,0, 0,0 ]), gl.STATIC_DRAW);
			gl.enableVertexAttribArray(rectanglePositionLocation);
			gl.vertexAttribPointer(rectanglePositionLocation, 2 /*size*/, gl.FLOAT /*type*/, false /*normalize*/, 0 /*stride*/, 0 /*offset*/);

			// ---------------------------------------------------------------------------------------------------
			//   Setup GLSL program for image-portion drawing:
			// ---------------------------------------------------------------------------------------------------

			var imagePortionProgram               = createProgram(gl, imagePortionVertexShader, imagePortionFragmentShader);
			var imagePortionAPosition             = gl.getAttribLocation(imagePortionProgram, "a_position");
			var imagePortionATexCoord             = gl.getAttribLocation(imagePortionProgram, "a_texcoord");
			var imagePortionMatrixLocation        = gl.getUniformLocation(imagePortionProgram, "u_matrix");
			var imagePortionTextureLocation       = gl.getUniformLocation(imagePortionProgram, "u_texture");
			var imagePortionTextureMatrixLocation = gl.getUniformLocation(imagePortionProgram, "u_textureMatrix");

			var imagePortionVao = gl.createVertexArray();
			gl.bindVertexArray(imagePortionVao);

			// Initialise imagePortionProgram.a_position array with the positions on an Unit Quad:
		
			var unitQuadBuffer = gl.createBuffer();
			gl.bindBuffer(gl.ARRAY_BUFFER, unitQuadBuffer);
			gl.bufferData(gl.ARRAY_BUFFER, new Float32Array([ 0,0, 0,1, 1,0, 1,0, 0,1, 1,1 ]), gl.STATIC_DRAW);
			gl.enableVertexAttribArray(imagePortionAPosition);
			gl.vertexAttribPointer(imagePortionAPosition, 2 /* size */, gl.FLOAT /* type */, false /* normalize */, 0 /* stride */, 0 /* offset */);

			// Initialise imagePortionProgram.a_texcoord array:
			
			var imagePortionTexCoordBuffer = gl.createBuffer();
			gl.bindBuffer(gl.ARRAY_BUFFER, imagePortionTexCoordBuffer);
			gl.bufferData(gl.ARRAY_BUFFER, new Float32Array([ 0,0, 0,1, 1,0, 1,0, 0,1, 1,1 ]), gl.STATIC_DRAW);
			gl.enableVertexAttribArray(imagePortionATexCoord);
			gl.vertexAttribPointer(imagePortionATexCoord, 2 /*size*/, gl.FLOAT /*type*/, true /*normalize*/, 0 /*stride*/, 0 /*offset*/);

			// ---------------------------------------------------------------------------------------------------
			//   Setup GLSL program for image one-to-one drawing  (no stretch):
			// ---------------------------------------------------------------------------------------------------

			var imageOneToOneProgram               = createProgram(gl, imageOneToOneVertexShader, imageOneToOneFragmentShader);
			var imageOneToOneAPosition             = gl.getAttribLocation(imageOneToOneProgram, "a_position");
			var imageOneToOneATexCoord             = gl.getAttribLocation(imageOneToOneProgram, "a_texcoord");
			var imageOneToOneMatrixLocation        = gl.getUniformLocation(imageOneToOneProgram, "u_matrix");
			var imageOneToOneTextureLocation       = gl.getUniformLocation(imageOneToOneProgram, "u_texture");

			var imageOneToOneVao = gl.createVertexArray();
			gl.bindVertexArray(imageOneToOneVao);

			// Initialise imageOneToOneProgram.a_position array with the positions on an Unit Quad:
		
			// var unitQuadBuffer = gl.createBuffer();  --  because we re-use from above   TODO: clarify
			gl.bindBuffer(gl.ARRAY_BUFFER, unitQuadBuffer);
			// gl.bufferData(gl.ARRAY_BUFFER, new Float32Array([ 0,0, 0,1, 1,0, 1,0, 0,1, 1,1 ]), gl.STATIC_DRAW);  --  because we re-use from above   TODO: clarify
			gl.enableVertexAttribArray(imageOneToOneAPosition);
			gl.vertexAttribPointer(imageOneToOneAPosition, 2 /* size */, gl.FLOAT /* type */, false /* normalize */, 0 /* stride */, 0 /* offset */);

			// Initialise imageOneToOneProgram.a_texcoord array:
			
			var imageOneToOneTexCoordBuffer = gl.createBuffer();
			gl.bindBuffer(gl.ARRAY_BUFFER, imageOneToOneTexCoordBuffer);
			gl.bufferData(gl.ARRAY_BUFFER, new Float32Array([ 0,0, 0,1, 1,0, 1,0, 0,1, 1,1 ]), gl.STATIC_DRAW);
			gl.enableVertexAttribArray(imageOneToOneATexCoord);
			gl.vertexAttribPointer(imageOneToOneATexCoord, 2 /*size*/, gl.FLOAT /*type*/, true /*normalize*/, 0 /*stride*/, 0 /*offset*/);






			// ---------------------------------------------------------------------------------------------------
			//   Rectangle draw function
			// ---------------------------------------------------------------------------------------------------

			function drawRectangle(x, y, width, height, redf, greenf, bluef)
			{
				gl.useProgram(rectangleProgram);
				gl.bindVertexArray(rectangleVao);
				gl.uniformMatrix3fv(rectangleMatrixLocation, false, projectToRetroScreenMatrix);

				var r = x + width
				var b = y + height

				gl.bindBuffer(gl.ARRAY_BUFFER, rectangleBuffer);
				gl.bufferSubData(gl.ARRAY_BUFFER, 0 /* offset */, new Float32Array([x,y, r,y, r,b, r,b, x,y, x,b]));
				gl.uniform4f(rectangleColorLocation, redf, greenf, bluef, 1);   // Set colour
				gl.drawArrays(gl.TRIANGLES, 0 /*offset*/, 6 /*count*/);         // Draw the geometry.
			}

			// ---------------------------------------------------------------------------------------------------
			//   Image portion draw function
			// ---------------------------------------------------------------------------------------------------

			function drawImagePortion(
				tex, texWidth, texHeight, 
				srcX, srcY, srcWidth, srcHeight, 
				dstX, dstY, destWidth, destHeight) 
			{
				gl.useProgram(imagePortionProgram);
				gl.bindVertexArray(imagePortionVao);
				gl.uniform1i(imagePortionTextureLocation, 0 /* textureUnit */);
				gl.activeTexture(gl.TEXTURE0 + 0 /* textureUnit */);
				gl.bindTexture(gl.TEXTURE_2D, tex);

				var texMatrix = m3translation(srcX / texWidth, srcY / texHeight);
				texMatrix     = m3scale(texMatrix, srcWidth / texWidth, srcHeight / texHeight);
				gl.uniformMatrix3fv(imagePortionTextureMatrixLocation, false, texMatrix);
				
				var matrix = m3translate(projectToRetroScreenMatrix, dstX, dstY);
				matrix     = m3scale(matrix, destWidth, destHeight);
				gl.uniformMatrix3fv(imagePortionMatrixLocation, false, matrix);
				
				gl.drawArrays(gl.TRIANGLES, 0 /*offset*/, 6 /*count*/);
			}

			// ---------------------------------------------------------------------------------------------------
			//   Image one-to-one draw function
			// ---------------------------------------------------------------------------------------------------

			function drawImageOneToOne(tex, texWidth, texHeight, dstX, dstY)
			{
				gl.useProgram(imageOneToOneProgram);
				gl.bindVertexArray(imageOneToOneVao);
				gl.uniform1i(imageOneToOneTextureLocation, 0 /* textureUnit */);
				gl.activeTexture(gl.TEXTURE0 + 0 /* textureUnit */);
				gl.bindTexture(gl.TEXTURE_2D, tex);

				var matrix = m3translate(projectToRetroScreenMatrix, dstX, dstY);
				matrix     = m3scale(matrix, texWidth, texHeight);
				gl.uniformMatrix3fv(imageOneToOneMatrixLocation, false, matrix);

				gl.drawArrays(gl.TRIANGLES, 0 /*offset*/, 6 /*count*/);
			}

			// ---------------------------------------------------------------------------------------------------
			//   Examples
			// ---------------------------------------------------------------------------------------------------

			setInterval(

				function(){ 
				
					drawRectangle( 10, 10, 200, 150, 1.0, 0.5, 1.0);
					drawRectangle( 50, 90, 200, 150, 0.5, 0.5, 1.0);
					drawRectangle(170, 60, 100,  50, 1.0, 1.0, 0.5);
					
					var tex = gl.createTexture();
					gl.bindTexture(gl.TEXTURE_2D, tex);
					gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, gl.RGBA, gl.UNSIGNED_BYTE, image);
					// TODO: Do we need these?  gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.CLAMP_TO_EDGE);
					// TODO: Do we need these?  gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.CLAMP_TO_EDGE);
					gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.NEAREST);
					gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.NEAREST);
					
					drawImagePortion(
						tex, 12, 8, 
						0, 0, 12, 8,   // source
						70, 70, 120, 80);

					drawImagePortion(
						tex, 12, 8, 
						0, 0, 12, 8,   // source
						30, 70, 12, 8);

					drawImagePortion(
						tex, 12, 8, 
						1, 1, 10, 6,   // source
						130, 30, 20, 12);

					drawRectangle(0, 248, 320, 8, 1.0, 1.0, 1.0);

					var repeat;
					for(repeat=0; repeat<3; repeat++)
					{
						var y;
						for (y = 0; y < 25; y++)
						{
							var x;
							for (x = 0; x < 25; x++)
							{
								drawImageOneToOne(tex, 12,8, 10 + x*12, 16 + y*8);
								// drawImagePortion(
								// 	tex, 12, 8,
								// 	0,0,12,8,
								// 	10 + x*12, 16 + y*8, 12, 8);
							}
						}
					}
				
					 }, 
				20);  // 50FPS
		}



		// Asynchronously load an image
		var image = new Image();
		image.src = "brick-12-8.png";
		image.addEventListener('load', function() {
			console.log('Loaded image 1');
			main(image);
		});

    </script>

</body>
</html>
