<!doctype html>
<html style="margin:0; padding:0; border:0; width:100%; height:100%;">

<head>
	<title>WebGL2 spike page</title>
	<meta http-equiv='Content-Type' content='text/html; charset=utf-8'>
	<meta name="viewport" content="width=device-width, initial-scale=1">
</head>

<body style="margin:0; padding:0; border:0; width:100%; height:100%; overflow:hidden; background-color:#333;">

    <!-- Display canvas -->

	<canvas id="gameScreen" width="500" height="300">
		<p>Web Canvas isn't supported by this browser, so the game cannot be displayed.</p>
	</canvas>

    <!-- Supplementary scripts could possibly be done in F# itself through Fable -->

    <script>
  
  
		let MatType = Float32Array;
  
  
		/**
		* Computes a 4-by-4 orthographic projection matrix given the coordinates of the
		* planes defining the axis-aligned, box-shaped viewing volume.  The matrix
		* generated sends that box to the unit box.  Note that although left and right
		* are x coordinates and bottom and top are y coordinates, near and far
		* are not z coordinates, but rather they are distances along the negative
		* z-axis.  We assume a unit box extending from -1 to 1 in the x and y
		* dimensions and from -1 to 1 in the z dimension.
		* @param {number} left The x coordinate of the left plane of the box.
		* @param {number} right The x coordinate of the right plane of the box.
		* @param {number} bottom The y coordinate of the bottom plane of the box.
		* @param {number} top The y coordinate of the right plane of the box.
		* @param {number} near The negative z coordinate of the near plane of the box.
		* @param {number} far The negative z coordinate of the far plane of the box.
		* @param {Matrix4} [dst] optional matrix to store result
		* @return {Matrix4} dst or a new matrix if none provided
		* @memberOf module:webgl-3d-math
		*/
		function m4orthographic(left, right, bottom, top, near, far, dst) {
			dst = dst || new MatType(16);

			dst[ 0] = 2 / (right - left);
			dst[ 1] = 0;
			dst[ 2] = 0;
			dst[ 3] = 0;
			dst[ 4] = 0;
			dst[ 5] = 2 / (top - bottom);
			dst[ 6] = 0;
			dst[ 7] = 0;
			dst[ 8] = 0;
			dst[ 9] = 0;
			dst[10] = 2 / (near - far);
			dst[11] = 0;
			dst[12] = (left + right) / (left - right);
			dst[13] = (bottom + top) / (bottom - top);
			dst[14] = (near + far) / (near - far);
			dst[15] = 1;

			return dst;
		}
  
		/**
		* Multiply by translation matrix.
		* @param {Matrix4} m matrix to multiply
		* @param {number} tx x translation.
		* @param {number} ty y translation.
		* @param {number} tz z translation.
		* @param {Matrix4} [dst] optional matrix to store result
		* @return {Matrix4} dst or a new matrix if none provided
		* @memberOf module:webgl-3d-math
		*/
		function m4translate(m, tx, ty, tz, dst) {
			// This is the optimized version of
			// return multiply(m, translation(tx, ty, tz), dst);
			dst = dst || new MatType(16);

			var m00 = m[0];
			var m01 = m[1];
			var m02 = m[2];
			var m03 = m[3];
			var m10 = m[1 * 4 + 0];
			var m11 = m[1 * 4 + 1];
			var m12 = m[1 * 4 + 2];
			var m13 = m[1 * 4 + 3];
			var m20 = m[2 * 4 + 0];
			var m21 = m[2 * 4 + 1];
			var m22 = m[2 * 4 + 2];
			var m23 = m[2 * 4 + 3];
			var m30 = m[3 * 4 + 0];
			var m31 = m[3 * 4 + 1];
			var m32 = m[3 * 4 + 2];
			var m33 = m[3 * 4 + 3];

			if (m !== dst) {
				dst[ 0] = m00;
				dst[ 1] = m01;
				dst[ 2] = m02;
				dst[ 3] = m03;
				dst[ 4] = m10;
				dst[ 5] = m11;
				dst[ 6] = m12;
				dst[ 7] = m13;
				dst[ 8] = m20;
				dst[ 9] = m21;
				dst[10] = m22;
				dst[11] = m23;
			}

			dst[12] = m00 * tx + m10 * ty + m20 * tz + m30;
			dst[13] = m01 * tx + m11 * ty + m21 * tz + m31;
			dst[14] = m02 * tx + m12 * ty + m22 * tz + m32;
			dst[15] = m03 * tx + m13 * ty + m23 * tz + m33;

			return dst;
		}
  
		/**
		* Multiply by a scaling matrix
		* @param {Matrix4} m matrix to multiply
		* @param {number} sx x scale.
		* @param {number} sy y scale.
		* @param {number} sz z scale.
		* @param {Matrix4} [dst] optional matrix to store result
		* @return {Matrix4} dst or a new matrix if none provided
		* @memberOf module:webgl-3d-math
		*/
		function m4scale(m, sx, sy, sz, dst) {
			// This is the optimized version of
			// return multiply(m, scaling(sx, sy, sz), dst);
			dst = dst || new MatType(16);

			dst[ 0] = sx * m[0 * 4 + 0];
			dst[ 1] = sx * m[0 * 4 + 1];
			dst[ 2] = sx * m[0 * 4 + 2];
			dst[ 3] = sx * m[0 * 4 + 3];
			dst[ 4] = sy * m[1 * 4 + 0];
			dst[ 5] = sy * m[1 * 4 + 1];
			dst[ 6] = sy * m[1 * 4 + 2];
			dst[ 7] = sy * m[1 * 4 + 3];
			dst[ 8] = sz * m[2 * 4 + 0];
			dst[ 9] = sz * m[2 * 4 + 1];
			dst[10] = sz * m[2 * 4 + 2];
			dst[11] = sz * m[2 * 4 + 3];

			if (m !== dst) {
				dst[12] = m[12];
				dst[13] = m[13];
				dst[14] = m[14];
				dst[15] = m[15];
			}

			return dst;
		}

  
  
	
	
	
		function compileShader(gl, shaderSource, shaderType) {
		  // Create the shader object
		  var shader = gl.createShader(shaderType);
		 
		  // Set the shader source code.
		  gl.shaderSource(shader, shaderSource);
		 
		  // Compile the shader
		  gl.compileShader(shader);
		 
		  // Check if it compiled
		  var success = gl.getShaderParameter(shader, gl.COMPILE_STATUS);
		  if (!success) {
			// Something went wrong during compilation; get the error
			throw "could not compile shader:" + gl.getShaderInfoLog(shader);
		  }
		 
		  return shader;
		}	
			
		function compileVertexShaderFromScript(gl, shaderScript) {
		  return compileShader(gl, shaderScript, gl.VERTEX_SHADER);
		}

		function compileFragmentShaderFromScript(gl, shaderScript) {
		  return compileShader(gl, shaderScript, gl.FRAGMENT_SHADER);
		}
		
		function createProgram(gl, vertexShaderScript, fragmentShaderScript) {
		  // create a program.
		  var program = gl.createProgram();
		 
		  // attach the shaders.
		  gl.attachShader(program, compileVertexShaderFromScript(gl, vertexShaderScript));
		  gl.attachShader(program, compileFragmentShaderFromScript(gl, fragmentShaderScript));
		 
		  // link the program.
		  gl.linkProgram(program);
		 
		  // Check if it linked.
		  var success = gl.getProgramParameter(program, gl.LINK_STATUS);
		  if (!success) {
			  // something went wrong with the link
			  throw ("program filed to link:" + gl.getProgramInfoLog (program));
		  }
		 
		  return program;
		};	
	
		function resizeCanvasToDisplaySize(canvas) {
		  // Lookup the size the browser is displaying the canvas in CSS pixels.
		  const displayWidth  = canvas.clientWidth;
		  const displayHeight = canvas.clientHeight;
		 
		  // Check if the canvas is not the same size.
		  const needResize = canvas.width  !== displayWidth ||
							 canvas.height !== displayHeight;
		 
		  if (needResize) {
			// Make the canvas the same size
			canvas.width  = displayWidth;
			canvas.height = displayHeight;
		  }
		 
		  return needResize;
		}	
	
	
	
	
	
	
	
	

		var vs = 
		
			/*
			A Vertex Shader's job is to generate clipspace coordinates.
			
			Your shader is called once per vertex. Each time it's called 
			you are required to set the special global variable, 
			gl_Position to some clipspace coordinates.
			
			Vertex shaders need data. They can get that data in 3 ways.
			- Attributes (data pulled from buffers)
			- Uniforms (values that stay the same for all vertices of a single draw call)
			- Textures (data from pixels/texels)
			
			https://webgl2fundamentals.org/webgl/lessons/webgl-shaders-and-glsl.html
			*/
		
			`#version 300 es

			in vec4 a_position;
			in vec2 a_texcoord;

			uniform mat4 u_matrix;

			out vec2 v_texcoord;

			void main() {
			  gl_Position = u_matrix * a_position;
			  v_texcoord = a_texcoord;
			}`;



		var fs = 
		
			/*
			A Fragment Shader's job is to provide a color for the current pixel being rasterized.
			
			Your fragment shader is called once per pixel. Each time it's called you are required 
			to set your out variable to some color.
			
			Fragment shaders need data. They can get data in 3 ways
			- Uniforms (values that stay the same for every pixel of a single draw call)
			- Textures (data from pixels/texels)
			- Varyings (data passed from the vertex shader and interpolated)			
			*/
		
			`#version 300 es
			precision highp float;

			in vec2 v_texcoord;

			uniform sampler2D u_texture;

			out vec4 outColor;

			void main() {
				outColor = texture(u_texture, v_texcoord);
			}`;



		function main(image) {

			// Get A WebGL context
			/** @type {HTMLCanvasElement} */
			var canvas = document.getElementById("gameScreen");
			var gl = canvas.getContext("webgl2");
			if (!gl) {
				return;
			}

			// setup GLSL program
			var program = createProgram(gl, vs, fs);

			// lookup uniforms
			var matrixLocation = gl.getUniformLocation(program, "u_matrix");
			var textureLocation = gl.getUniformLocation(program, "u_texture");

			// Create a vertex array object (attribute state) and make it the one we're currently working with
			var vao = gl.createVertexArray();
			gl.bindVertexArray(vao);

			//
			// Initialise a_position array with the positions on an Unit Quad:
			//

			var positionArray = gl.createBuffer();
			gl.bindBuffer(gl.ARRAY_BUFFER, positionArray);
			var unitQuadPositions = [
				0, 0,
				0, 1,
				1, 0,
				1, 0,
				0, 1,
				1, 1,
			];
			gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(unitQuadPositions), gl.STATIC_DRAW);
			var aPosition = gl.getAttribLocation(program, "a_position");
			gl.enableVertexAttribArray(aPosition);   // Initialise the a_position attribute.
			gl.vertexAttribPointer(                  // This is metadata about the array. (Tell the attribute how to get data out of the positionBuffer array)
				aPosition, 
				2,         // size      -- 2 components per iteration
				gl.FLOAT,  // type      -- the data is 32bit floats
				false,     // normalize -- don't normalize the data
				0,         // stride    -- 0 = move forward size * sizeof(type) bytes each iteration to get the next position
				0);        // offset    -- start at the beginning of the buffer

			//
			// Initialise a_texcoord array:
			//

			var texcoordArray = gl.createBuffer();
			gl.bindBuffer(gl.ARRAY_BUFFER, texcoordArray);
			var texcoords = [
				0, 0,
				0, 1,
				1, 0,
				1, 0,
				0, 1,
				1, 1,
			];
			gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(texcoords), gl.STATIC_DRAW);
			var aTexCoord = gl.getAttribLocation(program, "a_texcoord");
			gl.enableVertexAttribArray(aTexCoord);
			gl.vertexAttribPointer(
				aTexCoord, 2 /*size*/, gl.FLOAT /*type*/, true /*normalize*/, 0 /*stride*/, 0 /*offset*/);

			//
			// Create the texture from the image that was passed in:
			//

			var tex = gl.createTexture();
			gl.bindTexture(gl.TEXTURE_2D, tex);
			gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.CLAMP_TO_EDGE);
			gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.CLAMP_TO_EDGE);
			gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, gl.RGBA, gl.UNSIGNED_BYTE, image);
			gl.generateMipmap(gl.TEXTURE_2D);

			resizeCanvasToDisplaySize(gl.canvas);

			// Tell WebGL how to convert from clip space to pixels
			gl.viewport(0, 0, gl.canvas.width, gl.canvas.height);

			// Clear the canvas
			gl.clearColor(0, 0, 0, 0);
			gl.clear(gl.COLOR_BUFFER_BIT | gl.DEPTH_BUFFER_BIT);

  

			// Unlike images, textures do not have a width and height associated
			// with them so we'll pass in the width and height of the texture
			function drawImage(tex, texWidth, texHeight, dstX, dstY) {
				gl.useProgram(program);

				// Setup the attributes for the quad
				gl.bindVertexArray(vao);

				var textureUnit = 0;
				// The the shader we're putting the texture on texture unit 0
				gl.uniform1i(textureLocation, textureUnit);

				// Bind the texture to texture unit 0
				gl.activeTexture(gl.TEXTURE0 + textureUnit);
				gl.bindTexture(gl.TEXTURE_2D, tex);

				// this matrix will convert from pixels to clip space
				var matrix = m4orthographic(
					0, gl.canvas.clientWidth, gl.canvas.clientHeight, 0, -1, 1);

				// translate our quad to dstX, dstY
				matrix = m4translate(matrix, dstX, dstY, 0);

				// scale our 1 unit quad
				// from 1 unit to texWidth, texHeight units
				matrix = m4scale(matrix, texWidth, texHeight, 1);

				// Set the matrix.
				gl.uniformMatrix4fv(matrixLocation, false, matrix);

				// draw the quad (2 triangles, 6 vertices)
				var offset = 0;
				var count = 6;
				gl.drawArrays(gl.TRIANGLES, offset, count);
			}



			drawImage(tex, image.width, image.height, 200, 150);
		}
		
			

		// Asynchronously load an image
		var image = new Image();
		image.src = "brick-12-8.png";
		image.addEventListener('load', function() {
			console.log('Loaded the image!');
			main(image);
		});
		

    </script>

</body>
</html>


